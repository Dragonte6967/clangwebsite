# 不只有整型变量哦！

在实际编程中，我们会遇到很多种类的变量。比如`18`岁，`9.90`包邮，发送`口令`抢红包，$\pi$的值大约是`3.1415926`，A的小写是`a`，某人的手机号是`13700000001`……等。上面简要介绍了整型的`18`，下面一起来仔细看一下这几种变量类型（专业术语叫**数据类型**）。

## 详细说说整型变量

上面我们介绍了简单的整型`int`的适用范围，除了`int`外，还有下面这几种整型：

| 类型             | 取值范围                        |
| ---------------- | :-----------------------------: |
| `unsigned int`   | $0 \to 4294967295 $             |
| `long`           | $-2147483648 \to 2147483647$ |
| `unsigned long`  |$0 \to 4294967295 $             |
| `short`          | $-32768 \to 32767$               |
| `unsigned short` | $0 \to 65535$                     |

这么多怎么记呢？~不记了！~ 大家先记下这个单词在C语言中的意思：`unsigned`无符号的。怎么理解？日常生活中**0和正数是不带正号的**吧！没错，就这么理解！只要`int`，`long`，`short`前面加上了这个单词，那它们就只能表示**非负整数**了。

另外，一个类型的取值区间的长度是固定的，也就是说一旦加了`unsigned`，这个类型就会**整体往数轴右边跑**，跑到它的左边界值到`0`上，所以，它的右边界会对应增加，刚好是之前右边界的**两倍再加一**。

还是记不住怎么办😭？那就直接不记了！如果你要计算的东西是正整数，在`int`不能满足的时候，就给它加上`unsigned`，变成`unsigned int`；如果还不行，就直接改成`unsigned long`。

要是左边界扛不住了咋办？直接把`int`改成`long`，再不行再加`unsigned`就可以了。~short：合计着我就没用呗~

总结一下顺序：

- 如果计算时只出现正整数：先`int`，再`unsigned int`，最后`unsigned long`；
- 如果计算时会出现负数：先`int`，再`long`，最后`unsigned long`。

> [!TIP]
>还不够怎么办？~TMD到底是什么运算要用这么长的数~
>
>杀手锏：`long long`：$-9223372036854775807 \to 9223372036854775807$
>
>应该够用了吧！🙂

## 再来看看小数们

在C语言中，小数们有了新的名字：**浮点类型**。下面是常见的三种浮点类型：

| 类型          | 取值范围                                   | 精确度   |
| ------------- | ------------------------------------------ | -------- |
| `float`       | $1.2\times10^{-38}\to3.4\times10^{38}$     | 6位小数  |
| `double`      | $2.3\times10^{-308}\to1.7\times10^{308}$   | 15位小数 |
| `long double` | $3.4\times10^{-4932}\to1.1\times10^{4932}$ | 没有确切精度，15位起步 |

大家可能对**精确度**没有什么概念，毕竟从左边界可以看出，支持的小数位数还是挺长的，最长的可以小数点后几千个数字。但实际上，它们并没有这么厉害。

下面给出一组案例来证明它们的实力，代码中有些内容目前还没有涉及，你只需要知道这些代码的任务都是让编译器照抄一遍我给它的小数。

**注：各组的运行结果中，<font color = #42b983>绿色的</font>是我后加的,方便大家对照，<font color = red>红色部分</font>是编译器精度超限后的“胡言乱语”，原代码中不会输出绿色部分，红色部分编译器会正常输出但不会帮你上色。**

<!-- tabs:start -->

### **float**

```clike
#include <stdio.h>

int main()
{
    float f = 3.1415926535897932384626;
	printf("%.22f",f);
}
```

运行结果

<font color = #42b983>3.1415926535897932384626</font>

3.141592<font color=red>7410125732421875</font>

不难看出，超出6位的精度限度后，就开始胡言乱语了

### **double**

```clike
#include <stdio.h>

int main()
{
    double f = 3.1415926535897932384626;
	printf("%.22f",f);
}
```

运行结果

<font color = #42b983>3.1415926535897932384626</font>

3.141592653589793<font color=red>1159980</font>

这位大哥是从15位开始，，

### **long double**

```clike
#include <stdio.h>

int main()
{
    long double f = 3.1415926535897932384626;
	printf("%.22Lf",f);
}
```

运行结果

<font color = #42b983>3.1415926535897932384626</font>

3.141592653589793<font color = red>1159980</font>

这位也是15位（本次测试用主机上是15位，大家的多少位可能会有所出入。）

<!-- tabs:end -->

大家可以根据计算精确度的需要，选择合适的类型，精确度不需要太高，比如保留两位小数，用float，精确度超过6位就用double。

得注意的是，并**不是精确度越高、取值区间越大，就越好**。取值区间和精确度的增长**会消耗更多的硬件资源**。尽管这一点资源对于一台现代电脑而言不值一提，但在一个项目中，可能同时会计算很多这种关于数字的函数，累加起来浪费的性能不容小觑。所以`short`也是有必要存在的，`short`类型的运算所需要的资源更少。

## 用来表示字的**字符型变量**`char`

`char`用来存储字符（character），包括英文字母、阿拉伯数字、半角标点（输入法英语状态的标点）。注意哦，不能存储汉字！`char`可以表示[anscii](https://c.runoob.com/front-end/6318/)表中的符号和字符。比如：

```clike
char c = 'A'
```
