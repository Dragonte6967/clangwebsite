# 一直都是这个变量，哪里变了？😡

经过前面的阅读，我们了解了一个C语言程序的基本结构，下面我们来看一下**变量**这个玩意儿。

> [!TIP]
> 和数学中的变量不同，这里的变量只有一种，没有自变量因变量这种说法。

## 啥是变量？

告诉编译器在何处创建变量的存储，以及如何创建变量的存储。简单地说，就是给要运算的东西**确定一下类型**然后**取个名字**。

比如说，小明的年龄是`18`岁，我们在程序中需要这么个东西，我们就可以这样来告诉编译器：

```clike 
int age = 18;
```

这样一个语句总共分为四个部分，`int`，`age`，`=`，`18`。我们一个一个来看 ~（一个一个一个……~

### `int`

可以理解为Integer，**整数**的意思，也就是确定了**我们需要的**“小明的年龄”是一个**整数**，不带小数点。如果你需要把一个变量`x`确定为`int`，请保证`x`满足：
 - -2147483648<`x`<2147483647 *不是啥大数运算应该都能满足吧🤔*；
 - 不是小数。

那如果我需要小数怎么办？不要着急，[后面](#不只有整型变量哦！)会介绍。

### `age`

这是变量的名字，简称**变量名**。由代码作者自己指定，在保证代码**只有自己阅读的情况下，可以随便取**，比如：

```clike
int ililioooOOOoOOolilililililililllllIIIIIIllllIIILil=0;
```
但过于复杂的变量名会给日后的bug排查带来极大的麻烦，通常不建议这么做。

还有一点是，C语言区分大小写，换句话说，下面两个东西`a`和`A`在编译器眼中大相迳庭：

```clike
int a = 0;
int A = 0;
```

我们推荐：
 - 用英语单词而不是拼音，比如`age`而不是`nianling`；
 - 用首字母大写的方式区别不同单词，比如`bigBag`或`SmallerOne`，这个命名方法叫**驼峰命名法**，前面一个首字母大写叫**大驼峰**，后面一个首字母小写，叫**小驼峰**。

至于用哪种驼峰，C语言中并没有明确要求（存疑），尽量保证一份源代码中只使用一种驼峰。

> [!NOTE]
>这里还有一份**保留字**表，这些单词已经有了自己的任务，请在命名的时候避开这些单词！
>
>```
>int long short float double char unsigned signed const void 
>volatile enum struct union if else goto swith case do while 
>for continue break return default typedef auto register extern 
>static sizeof
>```
>
>记不住也没关系，我相信大家不会用这些抽象的单词😂。值得注意的是，这些单词是**不能直接作为变量名**。上面讲到，C语言区分大小写，所以执意要用这些单词的话，把里面的某个或多个字母大写也是可以的。此外，做一些改动后当变量名也是允许的，比如这些：`forYa`，`JustdoIt`。

### `=`

注意哦，这个可不是等号！这个叫**赋值号**！它的意思是**把右边的东西赋值给左边**，它是有方向性的，它只能从右边到左边。下面这种写法就是错误的，因为违反了方向性：

```clike
int 18 = age;
```

### `18`

这位是变量的值，我们代码上写的是变量的名字，实际上参与运算的是变量的值，这一点和数学是一致的。

好，这些就是**声明**一个整型变量的步骤（声明：告诉编译器某些东西的语句就叫声明）。如果要用小数进行计算怎么办呢？下面是解决方法：

## 不只有整型变量哦！

在实际编程中，我们会遇到很多种类的变量。比如`18`岁，`9.90`包邮，发送`口令`抢红包，$\pi$的值大约是`3.1415926`，A的小写是`a`，某人的手机号是`13700000001`……等。上面简要介绍了整型的`18`，下面一起来仔细看一下这几种变量类型（专业术语叫**数据类型**）。

### 详细说说整型变量

上面我们介绍了简单的整型`int`的适用范围，除了`int`外，还有下面这几种整型：

| 类型             | 取值范围                        |
| ---------------- | :-----------------------------: |
| `unsigned int`   | $0 \to 4294967295 $             |
| `long`           | $-2147483648 \to 2147483647$ |
| `unsigned long`  |$0 \to 4294967295 $             |
| `short`          | $-32768 \to 32767$               |
| `unsigned short` | $0 \to 65535$                     |

这么多怎么记呢？~不记了！~ 大家先记下这个单词在C语言中的意思：`unsigned`无符号的。怎么理解？日常生活中**0和正数是不带正号的**吧！没错，就这么理解！只要`int`，`long`，`short`前面加上了这个单词，那它们就只能表示**非负整数**了。

另外，一个类型的取值区间的长度是固定的，也就是说一旦加了`unsigned`，这个类型就会**整体往数轴右边跑**，跑到它的左边界值到`0`上，所以，它的右边界会对应增加，刚好是之前右边界的**两倍再加一**。

还是记不住怎么办😭？那就直接不记了！如果你要计算的东西是正整数，在`int`不能满足的时候，就给它加上`unsigned`，变成`unsigned int`；如果还不行，就直接改成`unsigned long`。

要是左边界扛不住了咋办？直接把`int`改成`long`，再不行再加`unsigned`就可以了。~short：合计着我就没用呗~

总结一下顺序：

- 如果计算时只出现正整数：先`int`，再`unsigned int`，最后`unsigned long`；
- 如果计算时会出现负数：先`int`，再`long`，最后`unsigned long`。

> [!TIP]
>还不够怎么办？~TMD到底是什么运算要用这么长的数~
>
>杀手锏：`long long`：$-9223372036854775807 \to 9223372036854775807$
>
>应该够用了吧！🙂

### 再来看看小数们

在C语言中，小数们有了新的名字：**浮点类型**。下面是常见的三种浮点类型：

| 类型          | 取值范围                                   | 精确度   |
| ------------- | ------------------------------------------ | -------- |
| `float`       | $1.2\times10^{-38}\to3.4\times10^{38}$     | 6位小数  |
| `double`      | $2.3\times10^{-308}\to1.7\times10^{308}$   | 15位小数 |
| `long double` | $3.4\times10^{-4932}\to1.1\times10^{4932}$ | 没有确切精度，15位起步 |

大家可能对**精确度**没有什么概念，毕竟从左边界可以看出，支持的小数位数还是挺长的，最长的可以小数点后几千个数字。但实际上，它们并没有这么厉害。

下面给出一组案例来证明它们的实力，代码中有些内容目前还没有涉及，你只需要知道这些代码的任务都是让编译器照抄一遍我给它的小数。

**注：各组的运行结果中，<font color = #42b983>绿色的</font>是我后加的,方便大家对照，<font color = red>红色部分</font>是编译器精度超限后的“胡言乱语”，原代码中不会输出绿色部分，红色部分编译器会正常输出但不会帮你上色。**

<!-- tabs:start -->

### **float**

```clike
#include <stdio.h>

int main()
{
    float f = 3.1415926535897932384626;
	printf("%.22f",f);
}
```

运行结果

<font color = #42b983>3.1415926535897932384626</font>

3.141592<font color=red>7410125732421875</font>

不难看出，超出6位的精度限度后，就开始胡言乱语了

### **double**

```clike
#include <stdio.h>

int main()
{
    double f = 3.1415926535897932384626;
	printf("%.22f",f);
}
```

运行结果

<font color = #42b983>3.1415926535897932384626</font>

3.141592653589793<font color=red>1159980</font>

这位大哥是从15位开始，，

### **long double**

```clike
#include <stdio.h>

int main()
{
    long double f = 3.1415926535897932384626;
	printf("%.22Lf",f);
}
```

运行结果

<font color = #42b983>3.1415926535897932384626</font>

3.141592653589793<font color = red>1159980</font>

这位也是15位（本次测试用主机上是15位，大家的多少位可能会有所出入。）

<!-- tabs:end -->

大家可以根据计算精确度的需要，选择合适的类型，精确度不需要太高，比如保留两位小数，用float，精确度超过6位就用double。

得注意的是，并**不是精确度越高、取值区间越大，就越好**。取值区间和精确度的增长**会消耗更多的硬件资源**。尽管这一点资源对于一台现代电脑而言不值一提，但在一个项目中，可能同时会计算很多这种关于数字的函数，累加起来浪费的性能不容小觑。所以`short`也是有必要存在的，`short`类型的运算所需要的资源更少.